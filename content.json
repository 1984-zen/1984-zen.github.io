{"pages":[],"posts":[{"title":"認識Closure(閉包)","text":"閉包簡短的定義：巢狀的function就可能會發生閉包，閉包就是用內層去使用外層的物件使用閉包時要注意：閉包雖然簡單易用，但也會造成佔用記憶體的問題。因為會讓函式執行完畢後，某些情況下，閉包的變數仍然無法釋放記憶體，所以使用閉包時還是要謹慎小心。 來看一個閉包的例子12345678910function foo(){ let a =0; function run(){ a++; return a } return run;}var f = foo();console.log(f());執行結果123f() //1f() //2f() //3 上面程式碼的大意： 我們來看函式foo定義了三件事： a = 0 定義函式run return 函式run 而函式run定義了兩件事： a++ return a結果：每執行一次f()，a的結果就會加1也就是closure發生了記憶體讓內層a的值，不會被釋放記憶閉包本質上就是一個匿名函式也因為程式碼只執行傳回函式 對foo()而言，內層的function run()是函式run() 對f而言，內層的函式function run()是一個匿名函式function(){}實際上，印出 f() 函式的範例中，建立了一個閉包(匿名函式)，在執行傳回函式run時這個匿名函式只做a++和return a，且即使foo()已經執行完畢，a變數依然是存活在傳回的閉包範疇(記憶體)中。重點閉包將變數a本身關閉在自己的範疇(記憶體)中，而不是變數的值","link":"/closure/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/hello-world/"},{"title":"關於callback","text":"什麼是callback?callback就是他事情做完後接著要做什麼事情關於JavaScript的非同步Javascript在執行時，是單執行緒來執行，且以先佔式多工的模式，做法就是先把所有工作都按順序接下來，然後先做一些工作A，在做一些工作B，在做一些工作B，接著在做一些工作C，不斷重複，直到所有工作都完成為止，ABC的工作完成時間都不同，這代表如果你想編寫可順利運行的程式，就必須用非同步的方式思考。最早期Javascript就已經有一種非同步執行的機制，但隨著成長，JavaScript也加入新的功能，來管理非同步程式設計，我們可以將它想成有三個不同時代的非同步支援：callback時代，Promise時代，與產生器時代。為什麼需要callback首先要談到以下三個設計： 結構化程式設計：在直接控制移轉上加上規範。 物件導向程式設計：在間接控制移轉上加上規範。 函數程式設計：在變數賦值上加上規範。因為物件導向設計無法處理非同問題，所以我們需要callback寫程式囉！1234567891011function mainFunction(callback){ //這個callback是一個變數名稱，一開始他還不知道他是誰 var someData = 'Hello'; callback(someData); //這裡定義了此函式：此函式的callback這個function被執行，且到時候會將someData傳入參數}mainFunction(function(a){ //這時候上面的callback知道他是誰了，callback (是) 這行函數。傳入的時候a = someData console.log(a)); //印出Hello})mainFunction(function(b){ //同上執行步驟 console.log(b);})執行結果12HelloHello＃ 補充教材1 變數可以存入函式(在JasCript的世界中變數或function都是物件)12345678910function oldFunction(){ console.log('old');}let newFunction = oldFunction;// 確實有oldFunciotn的函式等著被觸發，但是只要沒有在後面加上()，就不會有觸發行為。所以這裡只是指定變數名稱但沒有執行的行為// 試想，若newFunction = 3// 那麼底下的觸發就會變成3()，這樣結果會找不到叫做function 3的可以執行而錯誤newFunction();補充教材2 同上一題，但是反過來123456789function mainFunction(callback){ //第一步：一開始callback不知道他是誰 callback(); //最後：知道這裡要執行cool()}function cool(){ console.log('coooool'); //這裡定義了cool()要做的事情}mainFunction(cool); // 然後第二步：cllback (是) cool補充教材3 var是全域宣告 let有scope，只會取同一層最近的let值123let a = 123;console.log(a);//結果：123但是1234{let a = 123}console.log(a);//undefine//{}大括號是表示區塊補充教材4 一個完整個函式包含：input, 儲存, outpput1234567891011121314let add = function(a,b) { return a + b; //return是output = 5}let calc = function(num1, num2, callback) { return callback(num1, num2); //知道了去執行add(2,3)}//如同下：let calc = function(num1, num2, callback) { let result = callback(num1, num2); return result;}console.log(calc(2,3,add)); //知道callback (是)add","link":"/callback/"},{"title":"學習 express-generator","text":"安裝-g 表示要安裝在全域1$ npm install express-generator --save -g 創建一個新的EXPRESS scaffold1$ express [project name] 完成","link":"/learning-express-generator/"},{"title":"使用Passport.js實作GitHub第三方登入驗證機制","text":"前言為提升自己的學習所隨手寫的筆記，可能會發生部分只有小編能看懂的地方 0. 版本與環境12作業系統： Mac OS 10.15Nodejs:： v10.15.3 前置：擁有一個EXPRESS專案如果您還沒有EXPRESS專案，請先跟著我之前的文章安裝express-generator。然後我們執行下面的指令建立專案。$ express 安裝 安裝passport，可參考Passport官網 1$ npm install passport --save passport本身就像是一個鑰匙圈，可以新增很多把驗證鑰匙套進去passport 安裝passport-gihub(加入passport的鑰匙圈裡) 1$ npm install passport-github --save 安裝express-sessionpassport 本身只提供驗證機制，其他過程中如果需要功能像是 session 則是交給其他 Middleware。這邊我們則使用 express-session 來處理。 1$ npm install","link":"/passportjs/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"EXPRESS","slug":"EXPRESS","link":"/tags/EXPRESS/"}],"categories":[]}